<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Proto-Linguistics Puzzle</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            touch-action: manipulation; /* Improves touch responsiveness on mobile */
        }
        .menu-card {
            transition: transform 0.3s, box-shadow 0.3s;
        }
        .menu-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }
        .glyph {
            display: inline-block;
            min-width: 24px;
            text-align: center;
            transition: background-color 0.3s, transform 0.2s;
            padding: 5px;
            border-radius: 4px;
            cursor: pointer;
        }
        .glyph.selected { background-color: #fef08a; transform: scale(1.1); font-weight: bold; }
        .glyph.correct { background-color: #bbf7d0; cursor: default; }
        .glyph.incorrect { background-color: #fecaca; }
        .question-card { transition: opacity 0.5s, transform 0.5s; }
        .fade-in { opacity: 1 !important; transform: translateY(0) !important; }
        .fade-out { opacity: 0; transform: translateY(20px); }
        .btn { transition: background-color 0.2s, transform 0.2s; }
        .btn:hover { transform: translateY(-2px); }
        .btn:active { transform: translateY(0); }
    </style>
</head>
<body class="bg-gray-100 text-gray-800">

    <!-- Main Menu Screen -->
    <div id="main-menu" class="flex flex-col items-center justify-center min-h-screen p-4">
        <h1 class="text-4xl md:text-5xl font-bold text-gray-900 mb-2">Proto-Linguistics Puzzle</h1>
        <p class="text-lg text-gray-600 mb-12">Select a language family to explore.</p>
        <div id="language-selection" class="grid grid-cols-1 md:grid-cols-3 gap-8 w-full max-w-6xl">
            <!-- Language family cards will be injected here -->
        </div>
    </div>

    <!-- Game Screen (hidden by default) -->
    <div id="game-screen" class="hidden w-full max-w-5xl mx-auto p-4 md:p-8">
        <div class="bg-white p-6 md:p-8 rounded-2xl shadow-lg">
            <div class="flex justify-between items-start mb-6">
                <div class="text-center flex-grow">
                    <h1 id="game-title" class="text-3xl md:text-4xl font-bold text-gray-900"></h1>
                    <p id="gloss-display" class="text-xl text-gray-600 mt-2 italic"></p>
                </div>
                <button id="back-to-menu-btn" class="bg-gray-200 text-gray-700 font-bold py-2 px-4 rounded-lg hover:bg-gray-300 btn">Menu</button>
            </div>

            <div class="flex justify-between items-center mb-6 bg-gray-50 p-4 rounded-lg">
                <div>
                    <span class="font-bold text-lg">Score:</span>
                    <span id="score" class="font-bold text-lg text-indigo-600">0</span>
                </div>
                <div>
                    <span class="font-bold text-lg">Word:</span>
                    <span id="word-counter" class="font-bold text-lg text-gray-700"></span>
                </div>
            </div>

            <div id="words-display" class="grid grid-cols-1 gap-x-8 gap-y-4 mb-8 text-lg md:text-xl"></div>

            <div id="heuristic-card" class="bg-indigo-50 p-6 rounded-lg shadow-inner hidden">
                <div id="question-container" class="question-card fade-out">
                    <p id="question-text" class="text-lg font-semibold mb-4 text-center text-indigo-900"></p>
                    <div id="answer-buttons" class="flex flex-col sm:flex-row gap-4 justify-center"></div>
                </div>
            </div>

            <div id="feedback-container" class="text-center mt-4">
                <div id="proto-word-container" class="h-10 mb-2">
                    <p id="proto-word-display" class="text-2xl font-bold text-indigo-600 hidden"></p>
                </div>
                <p id="feedback-text" class="text-xl font-semibold h-8"></p>
                <button id="next-word-btn" class="mt-4 bg-indigo-600 text-white font-bold py-3 px-8 rounded-lg shadow-md hover:bg-indigo-700 btn hidden">Next Word</button>
            </div>
        </div>
    </div>
        <!--
            TODO Items / Future Features:
            - Conditioned Sound Change
            - Consonant Clusters
            - Analogy
            - Borrowing
        -->
    <script>

        document.addEventListener('DOMContentLoaded', () => {
            // --- DATASETS ---
            const datasets = {
                polynesian: {
                    name: "Polynesian",
                    description: "Reconstruct Proto-Polynesian from its modern descendants like Hawaiian and Maori.",
                    rules: {
                        'k_lenition': { name: "K-Lenition", type: "phonological", change: "*k > ʔ", description: "The proto-sound *k becomes a glottal stop.", naturalness: 8 },
                        'l_rhotacism': { name: "L-Rhotacism", type: "phonological", change: "*l > r", description: "The proto-sound *l becomes an r-sound.", naturalness: 7 },
                        'l_glottalization': { name: "L-Glottalization", type: "phonological", change: "*l > ʔ", description: "The proto-sound *l becomes a glottal stop.", naturalness: 6 },
                        'f_debuccalization': { name: "F-Debuccalization", type: "phonological", change: "*f > h", description: "The proto-sound *f weakens to an h-sound.", naturalness: 8 },
                        'f_fortition': { name: "F-Fortition", type: "phonological", change: "*f > wh", description: "The proto-sound *f shifts to a wh-sound.", naturalness: 5 },
                        't_velarization': { name: "T-Velarization", type: "phonological", change: "*t > k", description: "The proto-sound *t shifts to a k-sound.", naturalness: 4 },
                        'reduplication_intensifier': { name: "Reduplication (Intensifier)", type: "morphological", description: "The word is repeated to intensify its meaning." }
                    },
                    words: [
                        { 
                            gloss: 'black',
                            proto_graphemes: ['k', 'e', 'l', 'e'],
                            daughter_languages: [
                                { name: 'hawaiian',  word: 'ʔele',      transformations: ['k_lenition'] },
                                { name: 'maori',     word: 'kere',      transformations: ['l_rhotacism'] },
                                { name: 'tongan',    word: 'kele',      transformations: [] },
                                { name: 'samoan',    word: 'ʔele',      transformations: ['k_lenition'] },
                                { name: 'tahitian',  word: 'ʔere',      transformations: ['k_lenition', 'l_rhotacism'] },
                                { name: 'rapanui',   word: 'kerekere',  transformations: ['l_rhotacism', 'reduplication_intensifier'] },
                                { name: 'marquesan', word: 'keʔe',      transformations: ['l_glottalization'] }
                            ]
                        },
                        { 
                            gloss: 'red',
                            proto_graphemes: ['k', 'u', 'l', 'a'],
                            daughter_languages: [
                                { name: 'hawaiian',  word: 'ʔula',      transformations: ['k_lenition'] },
                                { name: 'maori',     word: 'kura',      transformations: ['l_rhotacism'] },
                                { name: 'tongan',    word: 'kula',      transformations: [] },
                                { name: 'samoan',    word: 'ʔula',      transformations: ['k_lenition'] },
                                { name: 'tahitian',  word: 'ʔura',      transformations: ['k_lenition', 'l_rhotacism'] },
                                { name: 'rapanui',   word: 'kura',      transformations: ['l_rhotacism'] },
                                { name: 'marquesan', word: 'kuʔa',      transformations: ['l_glottalization'] }
                            ]
                        },
                        {
                            gloss: 'house',
                            proto_graphemes: ['f', 'a', 'l', 'e'],
                            daughter_languages: [
                                { name: 'hawaiian',  word: 'hale',      transformations: ['f_debuccalization'] },
                                { name: 'maori',     word: 'whare',     transformations: ['f_fortition', 'l_rhotacism'] },
                                { name: 'tongan',    word: 'fale',      transformations: [] },
                                { name: 'samoan',    word: 'fale',      transformations: [] },
                                { name: 'tahitian',  word: 'fare',      transformations: ['l_rhotacism'] },
                                { name: 'rapanui',   word: 'hare',      transformations: ['f_debuccalization', 'l_rhotacism'] },
                                { name: 'marquesan', word: 'haʔe',      transformations: ['f_debuccalization', 'l_glottalization'] }
                            ]
                        },
                        {
                            gloss: 'taro',
                            proto_graphemes: ['t', 'a', 'l', 'o'],
                            daughter_languages: [
                                { name: 'hawaiian',  word: 'kalo',      transformations: ['t_velarization'] },
                                { name: 'maori',     word: 'taro',      transformations: ['l_rhotacism'] },
                                { name: 'tongan',    word: 'talo',      transformations: [] },
                                { name: 'samoan',    word: 'talo',      transformations: [] },
                                { name: 'tahitian',  word: 'taro',      transformations: ['l_rhotacism'] },
                                { name: 'rapanui',   word: 'taro',      transformations: ['l_rhotacism'] },
                                { name: 'marquesan', word: 'taʔo',      transformations: ['l_glottalization'] }
                            ]
                        },
                        {
                            gloss: 'urinate',
                            proto_graphemes: ['m', 'i', 'm', 'i'],
                            daughter_languages: [
                                { name: 'hawaiian',  word: 'mimi',      transformations: [] },
                                { name: 'maori',     word: 'mimi',      transformations: [] },
                                { name: 'tongan',    word: 'mimi',      transformations: [] },
                                { name: 'samoan',    word: 'mimi',      transformations: [] },
                                { name: 'tahitian',  word: 'mimi',      transformations: [] },
                                { name: 'rapanui',   word: 'mimi',      transformations: [] },
                                { name: 'marquesan', word: 'mimi',      transformations: [] }
                            ]
                        }
                    ]
                },
                germanic: {
                    name: "Germanic",
                    description: "Use English, German, and Dutch to find Proto-Germanic roots and uncover Grimm's Law.",
                    rules: {
                        'p_to_f': { name: "Grimm's Law (p>f)", type: "phonological", change: "*p > f", naturalness: 8 },
                        't_to_th': { name: "Grimm's Law (t>th)", type: "phonological", change: "*t > th", naturalness: 8 },
                        'k_to_h': { name: "Grimm's Law (k>h)", type: "phonological", change: "*k > h", naturalness: 8 },
                        'kw_to_h': { name: "Grimm's Law (kw>h)", type: "phonological", change: "*kw > h", naturalness: 7 },
                        't_to_d': { name: "Verner's Law (t>d)", type: "phonological", change: "*t > d", naturalness: 7 },
                        'd_to_t': { name: "Final Devoicing", type: "phonological", change: "*d > t", naturalness: 6 },
                        'd_to_s': { name: "High German Shift (d>s)", type: "phonological", change: "*d > ß", naturalness: 5 },
                        's_deletion': { name: "Final S-Deletion", type: "phonological", change: "*s > null", naturalness: 6 }
                    },
                    words: [
                        {
                            gloss: 'father',
                            proto_graphemes: ['p', 'a', 't', 'e', 'r'],
                            daughter_languages: [
                                { name: 'english', word: 'father', graphemes: ['f','a','th','e','r'], transformations: ['p_to_f', 't_to_th'] },
                                { name: 'german',  word: 'vater',  graphemes: ['v','a','t','e','r'],  transformations: ['p_to_f'] },
                                { name: 'dutch',   word: 'vader',  graphemes: ['v','a','d','e','r'],  transformations: ['p_to_f', 't_to_d'] }
                            ]
                        },
                        {
                            gloss: 'foot',
                            proto_graphemes: ['p', 'ō', 'd'],
                            daughter_languages: [
                                { name: 'english', word: 'foot', graphemes: ['f','oo','t'], transformations: ['p_to_f', 'd_to_t'] },
                                { name: 'german',  word: 'fuß',  graphemes: ['f','u','ß'],  transformations: ['p_to_f', 'd_to_s'] },
                                { name: 'dutch',   word: 'voet', graphemes: ['v','oe','t'],  transformations: ['p_to_f', 'd_to_t'] }
                            ]
                        },
                        {
                            gloss: 'three',
                            proto_graphemes: ['t', 'r', 'ē', 's'],
                            daughter_languages: [
                                { name: 'english', word: 'three', graphemes: ['th','r','ee'], transformations: ['t_to_th', 's_deletion'] },
                                { name: 'german',  word: 'drei',  graphemes: ['d','r','ei'],  transformations: ['t_to_d', 's_deletion'] },
                                { name: 'dutch',   word: 'drie',  graphemes: ['d','r','ie'],  transformations: ['t_to_d', 's_deletion'] }
                            ]
                        },
                        {
                            gloss: 'heart',
                            proto_graphemes: ['k', 'e', 'r', 'd'],
                            daughter_languages: [
                                { name: 'english', word: 'heart', graphemes: ['h','ea','r','t'], transformations: ['k_to_h', 'd_to_t'] },
                                { name: 'german',  word: 'herz',  graphemes: ['h','e','r','z'],  transformations: ['k_to_h', 'd_to_s'] },
                                { name: 'dutch',   word: 'hart',  graphemes: ['h','a','r','t'],  transformations: ['k_to_h', 'd_to_t'] }
                            ]
                        },
                        {
                            gloss: 'hound/dog',
                            proto_graphemes: ['k', 'w', 'o', 'n'],
                            daughter_languages: [
                                { name: 'english', word: 'hound', graphemes: ['h','ou','n','d'], transformations: ['kw_to_h'] },
                                { name: 'german',  word: 'hund',  graphemes: ['h','u','n','d'],  transformations: ['kw_to_h'] },
                                { name: 'dutch',   word: 'hond',  graphemes: ['h','o','n','d'],  transformations: ['kw_to_h'] }
                            ]
                        }
                    ]
                },
                /*
                romance: { ... }
                */
            };

            const flowchartQuestions = [
                { id: 1, text: "Are all the highlighted sounds identical?" },
                { id: 2, text: "Is there a 'one vs. many' pattern? (e.g., most languages have one sound, others have another)" },
                { id: 3, text: "Is one sound change more 'natural' or common than the reverse? (e.g., sounds simplifying or being lost)" },
                { id: 4, text: "Based on the evidence, what was the most likely original proto-sound?" }
            ];

            // --- GAME STATE ---
            let gameState = { currentFamily: null, score: 0, currentWordIndex: 0 };
            let selectedGlyphInfo = null;
            let currentQuestionIndex = 0;
            let wordState = {};

            // --- UI ELEMENTS ---
            const mainMenuEl = document.getElementById('main-menu');
            const gameScreenEl = document.getElementById('game-screen');
            const languageSelectionEl = document.getElementById('language-selection');
            const gameTitleEl = document.getElementById('game-title');
            const glossDisplayEl = document.getElementById('gloss-display');
            const scoreEl = document.getElementById('score');
            const wordCounterEl = document.getElementById('word-counter');
            const wordsDisplayEl = document.getElementById('words-display');
            const protoWordDisplayEl = document.getElementById('proto-word-display');
            const heuristicCardEl = document.getElementById('heuristic-card');
            const questionContainerEl = document.getElementById('question-container');
            const questionTextEl = document.getElementById('question-text');
            const answerButtonsEl = document.getElementById('answer-buttons');
            const feedbackTextEl = document.getElementById('feedback-text');
            const nextWordBtn = document.getElementById('next-word-btn');
            const backToMenuBtn = document.getElementById('back-to-menu-btn');

            // --- PHONOLOGICAL ENGINE ---

            function parseRule(changeString) {
                const parts = changeString.split(' > ');
                const from = parts[0].replace('*', '');
                const to = parts[1];
                return { from, to };
            }

            function deriveWord(protoGraphemes, transformationIds) {
                let derivedGraphemes = [...protoGraphemes];
                const allRules = datasets[gameState.currentFamily].rules;

                transformationIds.forEach(ruleId => {
                    const rule = allRules[ruleId];
                    if (rule.type === 'phonological') {
                        const { from, to } = parseRule(rule.change);
                        derivedGraphemes = derivedGraphemes.map(g => (g === from ? to : g));
                    }
                });

                transformationIds.forEach(ruleId => {
                    const rule = allRules[ruleId];
                    if (rule.type === 'morphological' && ruleId === 'reduplication_intensifier') {
                        derivedGraphemes = [...derivedGraphemes, ...derivedGraphemes];
                    }
                });

                return derivedGraphemes.filter(g => g !== 'null');
            }

            // --- CORE GAME LOGIC ---
            
            function saveProgress() {
                if (!gameState.currentFamily) return;
                localStorage.setItem(`progress_${gameState.currentFamily}`, JSON.stringify({
                    score: gameState.score,
                    currentWordIndex: gameState.currentWordIndex
                }));
            }

            function loadProgress(familyKey) {
                const saved = localStorage.getItem(`progress_${familyKey}`);
                if (saved) {
                    return JSON.parse(saved);
                }
                return { score: 0, currentWordIndex: 0 };
            }

            function createMainMenu() {
                languageSelectionEl.innerHTML = '';
                Object.keys(datasets).forEach(key => {
                    const family = datasets[key];
                    const progress = loadProgress(key);
                    const card = document.createElement('div');
                    card.className = 'menu-card bg-white p-8 rounded-lg shadow-md cursor-pointer text-center';
                    card.innerHTML = `
                        <h2 class="text-2xl font-bold text-indigo-600 mb-2">${family.name}</h2>
                        <p class="text-gray-600 mb-4">${family.description}</p>
                        <p class="text-sm text-gray-500">Progress: Word ${progress.currentWordIndex + 1} | Score: ${progress.score}</p>
                    `;
                    card.onclick = () => startGame(key);
                    languageSelectionEl.appendChild(card);
                });
            }

            function startGame(familyKey) {
                gameState.currentFamily = familyKey;
                const progress = loadProgress(familyKey);
                gameState.score = progress.score;
                gameState.currentWordIndex = progress.currentWordIndex;
                gameTitleEl.textContent = `${datasets[familyKey].name} Puzzle`;
                mainMenuEl.classList.add('hidden');
                gameScreenEl.classList.remove('hidden');
                loadWord(gameState.currentWordIndex);
            }

            function goBackToMenu() {
                saveProgress();
                gameScreenEl.classList.add('hidden');
                mainMenuEl.classList.remove('hidden');
                createMainMenu();
            }
            
            function getProtoSoundForIndex(word, index) {
                const protoGraphemes = word.proto_graphemes;
                const mappedIndex = index % protoGraphemes.length;
                if (mappedIndex < protoGraphemes.length) {
                    const protoChar = protoGraphemes[mappedIndex];
                    return protoChar === null ? null : protoChar;
                }
                return null;
            }

            function analyzeCorrespondence(word, index) {
                const correspondenceSet = [];
                word.daughter_languages.forEach(lang => {
                    // Use pre-defined graphemes if they exist, otherwise derive them
                    const graphemes = lang.graphemes || deriveWord(word.proto_graphemes, lang.transformations);
                    const protoLength = word.proto_graphemes.length;
                    const mappedIndex = index % protoLength;
                    if (mappedIndex < graphemes.length) {
                        correspondenceSet.push(graphemes[mappedIndex]);
                    }
                });

                const uniqueSounds = [...new Set(correspondenceSet.filter(s => s))];
                
                if (uniqueSounds.length <= 1) {
                    return null; 
                }
                const q1Answer = 'No';

                const counts = correspondenceSet.reduce((acc, sound) => {
                    if(sound) acc[sound] = (acc[sound] || 0) + 1;
                    return acc;
                }, {});
                const hasOneVsMany = Object.values(counts).some(count => count === 1);
                const q2Answer = hasOneVsMany ? 'Yes' : 'No';

                const relevantRules = [];
                const protoSound = getProtoSoundForIndex(word, index);
                const allRules = datasets[gameState.currentFamily].rules;

                for (const ruleId in allRules) {
                    const rule = allRules[ruleId];
                    if (rule.type === 'phonological') {
                        const { from, to } = parseRule(rule.change);
                        if (from === protoSound && uniqueSounds.includes(to)) {
                            relevantRules.push(rule);
                        }
                    }
                }
                
                let q3Answer = 'No';
                if(relevantRules.length > 1) {
                    const maxNaturalness = Math.max(...relevantRules.map(r => r.naturalness));
                    const topRules = relevantRules.filter(r => r.naturalness === maxNaturalness);
                    if(topRules.length === 1) {
                        q3Answer = 'Yes';
                    }
                }

                const finalAnswer = `*${protoSound}`;

                return [q1Answer, q2Answer, q3Answer, finalAnswer];
            }

            function startHeuristicQuestions() {
                displayQuestion();
            }
            
            function displayQuestion() {
                const currentWord = datasets[gameState.currentFamily].words[gameState.currentWordIndex];
                const path = analyzeCorrespondence(currentWord, selectedGlyphInfo.mappedIndex);

                if (!path) {
                    feedbackTextEl.textContent = "This sound is stable and requires no analysis.";
                    setTimeout(() => finalizeGlyph(true), 1500);
                    return;
                }

                if (currentQuestionIndex >= flowchartQuestions.length - 1 || path[currentQuestionIndex] === null) {
                    displayFinalQuestion(path[path.length - 1]);
                    return;
                }

                const question = flowchartQuestions[currentQuestionIndex];
                questionTextEl.textContent = question.text;
                answerButtonsEl.innerHTML = '';
                const options = ["Yes", "No"];
                options.forEach(option => {
                    const button = document.createElement('button');
                    button.textContent = option;
                    button.className = 'bg-white text-indigo-700 font-semibold py-2 px-4 border border-indigo-300 rounded-lg hover:bg-indigo-100 btn';
                    button.onclick = () => handleAnswer(option);
                    answerButtonsEl.appendChild(button);
                });
                
                heuristicCardEl.classList.remove('hidden');
                setTimeout(() => questionContainerEl.classList.add('fade-in'), 50);
            }

            function displayFinalQuestion(correctAnswer) {
                currentQuestionIndex = flowchartQuestions.length - 1;
                const question = flowchartQuestions[currentQuestionIndex];
                questionTextEl.textContent = question.text;
                answerButtonsEl.innerHTML = '';
                const allProtoSounds = new Set();
                datasets[gameState.currentFamily].words.forEach(w => {
                    w.proto_graphemes.forEach(g => {
                        if(g && !/[aeiouāēīōū]/.test(g)) allProtoSounds.add(`*${g}`);
                    });
                });

                const options = new Set([correctAnswer]);
                while (options.size < 3 && options.size < allProtoSounds.size) {
                    const randomSound = Array.from(allProtoSounds)[Math.floor(Math.random() * allProtoSounds.size)];
                    if (randomSound !== correctAnswer) {
                        options.add(randomSound);
                    }
                }
                
                Array.from(options).sort(() => Math.random() - 0.5).forEach(option => {
                     const button = document.createElement('button');
                    button.textContent = option;
                    button.className = 'bg-white text-indigo-700 font-semibold py-2 px-4 border border-indigo-300 rounded-lg hover:bg-indigo-100 btn';
                    button.onclick = () => handleAnswer(option);
                    answerButtonsEl.appendChild(button);
                });
            }

            function handleAnswer(selectedAnswer) {
                Array.from(answerButtonsEl.children).forEach(btn => btn.disabled = true);
                const currentWord = datasets[gameState.currentFamily].words[gameState.currentWordIndex];
                const path = analyzeCorrespondence(currentWord, selectedGlyphInfo.mappedIndex);
                const correctAnswer = (currentQuestionIndex === flowchartQuestions.length - 1) 
                    ? path[path.length - 1] 
                    : path[currentQuestionIndex];

                if (selectedAnswer === correctAnswer) {
                    gameState.score += 10;
                    feedbackTextEl.textContent = "Correct!";
                    feedbackTextEl.className = 'text-xl font-semibold text-green-600 h-8';
                    if (currentQuestionIndex === flowchartQuestions.length - 1) {
                        setTimeout(() => finalizeGlyph(true), 1000);
                    } else {
                        currentQuestionIndex++;
                        setTimeout(() => {
                            feedbackTextEl.textContent = '';
                            displayQuestion();
                        }, 1000);
                    }
                } else {
                    gameState.score = Math.max(0, gameState.score - 5);
                    feedbackTextEl.textContent = `Not quite. That set is marked red. Try another.`;
                    feedbackTextEl.className = 'text-xl font-semibold text-red-600 h-8';
                    setTimeout(() => finalizeGlyph(false), 2000);
                }
                scoreEl.textContent = gameState.score;
            }

            function finalizeGlyph(wasCorrect) {
                questionContainerEl.classList.remove('fade-in');
                setTimeout(() => heuristicCardEl.classList.add('hidden'), 500);
                
                const mappedIndex = selectedGlyphInfo.mappedIndex;
                const glyphs = document.querySelectorAll(`.glyph[data-mapped-index='${mappedIndex}']`);
                
                if (wasCorrect) {
                    wordState[mappedIndex] = { status: 'correct' };
                    glyphs.forEach(g => {
                        g.classList.remove('selected', 'incorrect');
                        g.classList.add('correct');
                    });
                } else {
                    wordState[mappedIndex] = { status: 'incorrect', failedAt: currentQuestionIndex };
                    glyphs.forEach(g => {
                        g.classList.remove('selected');
                        g.classList.add('incorrect');
                    });
                    setTimeout(() => { if(feedbackTextEl.textContent.includes("marked red")) feedbackTextEl.textContent = ''; }, 2000);
                }
                
                selectedGlyphInfo = null;
                checkCompletion();
            }
            
            function checkCompletion() {
                const currentWord = datasets[gameState.currentFamily].words[gameState.currentWordIndex];
                const requiredConsonants = new Set(currentWord.proto_graphemes.filter(g => g && !/[aeiouāēīōū-]/.test(g)));
                const solvedConsonants = new Set();
                document.querySelectorAll('.glyph.correct').forEach(g => {
                    const proto = getProtoSoundForIndex(currentWord, parseInt(g.dataset.mappedIndex));
                    if (proto && !/[aeiouāēīōū-]/.test(proto)) {
                        solvedConsonants.add(proto);
                    }
                });

                let allRequiredSolved = requiredConsonants.size === solvedConsonants.size;
                if (allRequiredSolved) {
                    for (const consonant of requiredConsonants) {
                        if (!solvedConsonants.has(consonant)) {
                            allRequiredSolved = false;
                            break;
                        }
                    }
                }
                
                if (allRequiredSolved) {
                    nextWordBtn.classList.remove('hidden');
                    feedbackTextEl.textContent = "Word complete!";
                    feedbackTextEl.className = 'text-xl font-semibold text-blue-600 h-8';
                    protoWordDisplayEl.textContent = `Proto-Word: *${currentWord.proto_graphemes.join('')}`;
                    protoWordDisplayEl.classList.remove('hidden');
                }
            }

            function createGlyph(char, lang, index, mappedIndex) {
                const glyphEl = document.createElement('span');
                glyphEl.className = 'glyph p-1';
                if(char) glyphEl.textContent = char;
                glyphEl.dataset.lang = lang;
                glyphEl.dataset.index = index;
                glyphEl.dataset.mappedIndex = mappedIndex;
                return glyphEl;
            }

            /**
             * [REFACTORED] Loads a word using the new general schema.
             * It now uses pre-defined graphemes if available, otherwise it derives them.
             */
            function loadWord(index) {
                wordState = {}; 
                const familyData = datasets[gameState.currentFamily];
                if (index >= familyData.words.length) {
                    gameState.currentWordIndex = 0;
                }
                const word = familyData.words[index];

                wordsDisplayEl.innerHTML = '';
                selectedGlyphInfo = null;
                heuristicCardEl.classList.add('hidden');
                questionContainerEl.classList.remove('fade-in');
                feedbackTextEl.textContent = '';
                nextWordBtn.classList.add('hidden');
                glossDisplayEl.textContent = `Meaning: "${word.gloss}"`;
                protoWordDisplayEl.classList.add('hidden');
                scoreEl.textContent = gameState.score;
                wordCounterEl.textContent = `${index + 1} / ${familyData.words.length}`;

                word.daughter_languages.forEach(langData => {
                    const langContainer = document.createElement('div');
                    langContainer.className = 'flex items-center gap-4';
                    
                    const label = document.createElement('span');
                    label.className = 'w-28 font-bold text-gray-500 text-right';
                    label.textContent = langData.name.charAt(0).toUpperCase() + langData.name.slice(1);
                    langContainer.appendChild(label);

                    const wordContainer = document.createElement('div');
                    wordContainer.className = 'flex-1 flex flex-row flex-wrap';
                    wordContainer.dataset.lang = langData.name;
                    
                    const protoLength = word.proto_graphemes.length;
                    
                    // Use pre-defined graphemes if they exist, otherwise derive them.
                    const displayGraphemes = langData.graphemes || deriveWord(word.proto_graphemes, langData.transformations);

                    displayGraphemes.forEach((grapheme, i) => {
                        const mappedIndex = i % protoLength;
                        const glyphEl = createGlyph(grapheme, langData.name, i, mappedIndex);
                        if (grapheme === null) {
                            glyphEl.style.visibility = 'hidden';
                        }
                        wordContainer.appendChild(glyphEl);
                    });
                    langContainer.appendChild(wordContainer);
                    wordsDisplayEl.appendChild(langContainer);
                });

                document.querySelectorAll('.glyph').forEach(addGlyphListener);
                checkCompletion();
            }

            function addGlyphListener(glyph) {
                glyph.addEventListener('click', () => {
                    if (glyph.style.visibility === 'hidden' || selectedGlyphInfo) return;

                    const mappedIndex = parseInt(glyph.dataset.mappedIndex);
                    const statusInfo = wordState[mappedIndex] || {};

                    if (statusInfo.status === 'correct') return;

                    if (statusInfo.status === 'incorrect') {
                        currentQuestionIndex = statusInfo.failedAt || 0;
                        document.querySelectorAll(`.glyph[data-mapped-index='${mappedIndex}']`).forEach(g => g.classList.remove('incorrect'));
                    } else {
                        currentQuestionIndex = 0;
                    }
                    
                    const currentWord = datasets[gameState.currentFamily].words[gameState.currentWordIndex];
                    const protoSound = getProtoSoundForIndex(currentWord, mappedIndex);
                    
                    if (!protoSound || /[aeiouāēīōū-]/.test(protoSound)) {
                        feedbackTextEl.textContent = "Let's focus on the consonants for now.";
                        feedbackTextEl.className = 'text-lg font-semibold text-gray-500 h-8';
                        setTimeout(() => { if(feedbackTextEl.textContent.includes("consonants")) feedbackTextEl.textContent = '' }, 2000);
                        return;
                    }
                    
                    selectedGlyphInfo = { mappedIndex: mappedIndex, protoSound: protoSound };
                    document.querySelectorAll('.glyph.selected').forEach(g => g.classList.remove('selected'));
                    
                    document.querySelectorAll(`.glyph[data-mapped-index='${mappedIndex}']`).forEach(g => {
                        if (g.style.visibility !== 'hidden') {
                            g.classList.add('selected');
                        }
                    });
                    
                    startHeuristicQuestions();
                });
            }

            // --- EVENT LISTENERS ---
            nextWordBtn.addEventListener('click', () => {
                gameState.currentWordIndex++;
                if (gameState.currentWordIndex >= datasets[gameState.currentFamily].words.length) {
                    gameState.currentWordIndex = 0;
                }
                saveProgress();
                loadWord(gameState.currentWordIndex);
            });

            backToMenuBtn.addEventListener('click', goBackToMenu);

            // --- INITIALIZE ---
            createMainMenu();
        });
    </script>
</body>
</html>
