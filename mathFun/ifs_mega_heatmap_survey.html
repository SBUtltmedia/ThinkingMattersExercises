<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Integer IFS Operator Heatmap</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 1em;
            background-color: #e8eaf6;
            color: #333;
            margin: 0;
            height: 100vh;
            box-sizing: border-box;
            overflow-y: auto;
        }
        h1, p {
            text-align: center;
            margin-top: 0.5em;
            margin-bottom: 0.5em;
            flex-shrink: 0;
        }
        .controls {
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
            flex-shrink: 0;
        }
        .controls label {
            font-weight: bold;
        }
        .controls select {
            padding: 5px;
            border-radius: 4px;
            border: 1px solid #ccc;
        }
        .mega-heatmap-container {
            margin-top: 10px;
            width: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-grow: 1;
            overflow: auto;
            min-height: 0;
        }
        table.mega-heatmap-table {
            border-collapse: collapse;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            border: 1px solid #ccc;
        }
        table.mega-heatmap-table td {
            border: none;
            padding: 0;
        }
        table.mega-heatmap-table td:hover::after {
            content: attr(data-tooltip);
            position: absolute;
            transform: translate(5px, -25px);
            background-color: rgba(0,0,0,0.8);
            color: white;
            padding: 3px 6px;
            border-radius: 3px;
            font-size: 10px;
            white-space: nowrap;
            z-index: 10;
            pointer-events: none;
        }
    </style>
</head>
<body>

    <h1>Integer IFS Operator Heatmap</h1>
    <p>Each 4x4 arrangement of sub-grids represents one of the 16 Boolean operators.</p>
    <p>Generated with the integer recursive rule: <code>f0(p)=2p, f1(p)=2p+1</code>. Hover for cell info.</p>
    
    <div class="controls">
        <div>
            <label for="iterations-select">Iterations (m):</label>
            <select id="iterations-select">
                <option value="1">1 (8x8 total)</option>
                <option value="2">2 (16x16 total)</option>
                <option value="3">3 (32x32 total)</option>
                <option value="4" selected>4 (64x64 total)</option>
                <option value="5">5 (128x128 total)</option>
            </select>
        </div>
    </div>

    <div class="mega-heatmap-container">
        <table id="mega-heatmap-table" class="mega-heatmap-table">
            <tbody>
                <!-- Grid generated by JavaScript -->
            </tbody>
        </table>
    </div>

    <script>
        let ITERATIONS = 4;
        let SUB_GRID_SIZE = Math.pow(2, ITERATIONS);
        const OPERATORS_PER_ROW = 4;
        let TOTAL_GRID_SIZE = SUB_GRID_SIZE * OPERATORS_PER_ROW;

        const megaTableBody = document.getElementById('mega-heatmap-table').querySelector('tbody');
        const iterationsSelect = document.getElementById('iterations-select');
        const tableElement = megaTableBody.parentNode;

        const operatorDetails = [
            { id: 0,  name: "FALSE", binary: "0000" }, { id: 1,  name: "A AND B", binary: "0001" },
            { id: 2,  name: "A AND NOT B", binary: "0010" }, { id: 3,  name: "A", binary: "0011" },
            { id: 4,  name: "NOT A AND B", binary: "0100" }, { id: 5,  name: "B", binary: "0101" },
            { id: 6,  name: "A XOR B", binary: "0110" }, { id: 7,  name: "A OR B", binary: "0111" },
            { id: 8,  name: "A NOR B", binary: "1000" }, { id: 9,  name: "A XNOR B", binary: "1001" },
            { id: 10, name: "NOT B", binary: "1010" }, { id: 11, name: "B → A", binary: "1011" },
            { id: 12, name: "NOT A", binary: "1100" }, { id: 13, name: "A → B", binary: "1101" },
            { id: 14, name: "A NAND B", binary: "1110" }, { id: 15, name: "TRUE", binary: "1111" }
        ];

        function getIntegerRecursiveRule(operatorId) {
            if (operatorId < 0 || operatorId > 15) return null;
            const binaryString = operatorId.toString(2).padStart(4, '0');
            const b3 = parseInt(binaryString[0]), b2 = parseInt(binaryString[1]),
                  b1 = parseInt(binaryString[2]), b0 = parseInt(binaryString[3]);
            const f0 = (p) => 2 * p;
            const f1 = (p) => 2 * p + 1;
            return [ [(b3===1?f1:f0), (b2===1?f1:f0)], [(b1===1?f1:f0), (b0===1?f1:f0)] ];
        }

        function generateRecursiveGrid(operatorId, iterations) {
            const ruleMatrixFunctions = getIntegerRecursiveRule(operatorId);
            if (!ruleMatrixFunctions) return null;
            let currentGrid = [[0]];
            for (let iter = 0; iter < iterations; iter++) {
                const currentSize = Math.pow(2, iter);
                const nextSize = Math.pow(2, iter + 1);
                const nextGrid = Array(nextSize).fill(null).map(() => Array(nextSize).fill(0));
                for (let r_p = 0; r_p < currentSize; r_p++) {
                    for (let c_p = 0; c_p < currentSize; c_p++) {
                        const pVal = currentGrid[r_p][c_p];
                        nextGrid[2*r_p][2*c_p]     = ruleMatrixFunctions[0][0](pVal);
                        nextGrid[2*r_p][2*c_p + 1] = ruleMatrixFunctions[0][1](pVal);
                        nextGrid[2*r_p + 1][2*c_p] = ruleMatrixFunctions[1][0](pVal);
                        nextGrid[2*r_p+1][2*c_p+1] = ruleMatrixFunctions[1][1](pVal);
                    }
                }
                currentGrid = nextGrid;
            }
            return currentGrid;
        }

        function generateAndRenderMegaHeatmap() {
            const numIterations = parseInt(iterationsSelect.value, 10);
            ITERATIONS = numIterations;
            SUB_GRID_SIZE = Math.pow(2, ITERATIONS);
            TOTAL_GRID_SIZE = SUB_GRID_SIZE * OPERATORS_PER_ROW;

            console.log(`Generating integer IFS grid for size ${SUB_GRID_SIZE}x${SUB_GRID_SIZE}...`);
            
            megaTableBody.innerHTML = '';

            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;
            let occupiedHeight = 0;
            document.querySelectorAll('h1, p, .controls').forEach(el => {
                if (el.offsetParent !== null) {
                    const style = window.getComputedStyle(el);
                    occupiedHeight += el.offsetHeight + parseFloat(style.marginTop) + parseFloat(style.marginBottom);
                }
            });
            occupiedHeight = Math.max(120, occupiedHeight);

            const availableWidthForTable = viewportWidth * 0.95;
            const availableHeightForTable = (viewportHeight - occupiedHeight) * 0.95;
            const targetTableDimension = Math.min(availableWidthForTable, availableHeightForTable) * 0.95;
            let cellSize = Math.floor(targetTableDimension / TOTAL_GRID_SIZE);
            cellSize = Math.max(1, cellSize);

            const actualTableSize = TOTAL_GRID_SIZE * cellSize;
            tableElement.style.width = `${actualTableSize}px`;
            tableElement.style.height = `${actualTableSize}px`;

            const allSubGrids = [];
            operatorDetails.forEach(opDetail => {
                const gridData = generateRecursiveGrid(opDetail.id, ITERATIONS);
                let maxVal = 0;
                if(gridData) {
                    for(let r=0; r < gridData.length; r++) {
                        for(let c=0; c < gridData[r].length; c++) {
                            if(gridData[r][c] > maxVal) maxVal = gridData[r][c];
                        }
                    }
                }
                allSubGrids.push({ id: opDetail.id, name: opDetail.name, data: gridData, maxVal: maxVal || 1 });
            });

            const dividerColor = "#ccc";
            const dividerWidth = "1px";

            for (let mega_r = 0; mega_r < TOTAL_GRID_SIZE; mega_r++) {
                const rowElement = document.createElement('tr');
                for (let mega_c = 0; mega_c < TOTAL_GRID_SIZE; mega_c++) {
                    const cell = document.createElement('td');
                    cell.style.width = `${cellSize}px`;
                    cell.style.height = `${cellSize}px`;

                    if ((mega_c + 1) % SUB_GRID_SIZE === 0 && (mega_c + 1) < TOTAL_GRID_SIZE) {
                        cell.style.borderRight = `${dividerWidth} solid ${dividerColor}`;
                    }
                    if ((mega_r + 1) % SUB_GRID_SIZE === 0 && (mega_r + 1) < TOTAL_GRID_SIZE) {
                        cell.style.borderBottom = `${dividerWidth} solid ${dividerColor}`;
                    }

                    const opRow = Math.floor(mega_r / SUB_GRID_SIZE);
                    const opCol = Math.floor(mega_c / SUB_GRID_SIZE);
                    const operatorIndex = opRow * OPERATORS_PER_ROW + opCol;
                    
                    const sub_r = mega_r % SUB_GRID_SIZE;
                    const sub_c = mega_c % SUB_GRID_SIZE;

                    const subGridInfo = allSubGrids[operatorIndex];
                    const value = subGridInfo.data[sub_r][sub_c];
                    const grayscale = 255 - Math.floor((value / subGridInfo.maxVal) * 255);
                    cell.style.backgroundColor = `rgb(${grayscale},${grayscale},${grayscale})`;
                    cell.dataset.tooltip = `Op ${subGridInfo.id} (${subGridInfo.name}) [${sub_r},${sub_c}]: ${value}`;
                    
                    rowElement.appendChild(cell);
                }
                megaTableBody.appendChild(rowElement);
            }
            console.log(`Integer IFS grid populated.`);
        }

        iterationsSelect.addEventListener('change', generateAndRenderMegaHeatmap);

        function initializeGrid() {
            generateAndRenderMegaHeatmap();
        }
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initializeGrid);
        } else {
            setTimeout(initializeGrid, 50);
        }

        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(generateAndRenderMegaHeatmap, 250);
        });

    </script>
</body>
</html>
