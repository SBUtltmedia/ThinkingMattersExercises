<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Universal Constructor - Complexity Heatmap</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #0a0a0a;
            color: #e5e5e5;
        }
        .font-orbitron {
            font-family: 'Orbitron', sans-serif;
        }
        .glass-card {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 1rem;
        }
        .rug-container {
            position: relative;
            width: 100%;
            max-width: 600px;
            aspect-ratio: 1 / 1;
            border: 1px solid #444;
            border-radius: 0.5rem;
            background-color: #f0f0f0;
        }
        #rug-svg {
            width: 100%;
            height: 100%;
        }
        #pixel-heatmap-canvas {
            width: 100%;
            max-width: 600px;
            aspect-ratio: 1 / 1;
            image-rendering: pixelated; /* Ensures sharp pixels */
        }
        #rug-tooltip {
            position: absolute;
            visibility: hidden;
            background-color: rgba(10, 10, 10, 0.85);
            color: #fff;
            padding: 0.5rem 0.75rem;
            border-radius: 0.375rem;
            pointer-events: none;
            transition: opacity 0.2s;
            opacity: 0;
            font-size: 0.8rem;
            font-family: 'Orbitron', monospace;
            border: 1px solid #444;
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
            white-space: pre; /* Keep formatting */
        }
        /* Tooltip Styles */
        .tooltip-container {
            position: relative;
            display: inline-block;
            border-bottom: 1px dotted #a78bfa;
            cursor: help;
        }
        .tooltip-content {
            visibility: hidden;
            width: 320px;
            background-color: #18181b;
            color: #fff;
            text-align: left;
            border-radius: 6px;
            padding: 1rem;
            position: absolute;
            z-index: 10;
            bottom: 125%;
            left: 50%;
            margin-left: -160px;
            opacity: 0;
            transition: opacity 0.3s;
            border: 1px solid #3f3f46;
            font-family: 'Inter', sans-serif;
            font-size: 0.875rem;
        }
        .tooltip-container:hover .tooltip-content {
            visibility: visible;
            opacity: 1;
        }
        .tooltip-content pre {
            background-color: #0a0a0a !important;
        }
        .btn-glow {
            box-shadow: 0 0 5px #a78bfa, 0 0 10px #a78bfa, 0 0 15px #a78bfa;
            transition: all 0.3s ease;
        }
        .btn-glow:hover {
            box-shadow: 0 0 10px #c4b5fd, 0 0 20px #c4b5fd, 0 0 30px #c4b5fd;
            transform: translateY(-2px);
        }
    </style>
</head>
<body class="antialiased">

    <div class="container mx-auto px-4 py-12 md:py-20">

        <header class="text-center mb-16 md:mb-24">
            <h1 class="font-orbitron text-4xl md:text-6xl font-bold tracking-wider uppercase">
                The Universal <span class="text-violet-400">Constructor</span>
            </h1>
            <p class="mt-4 text-lg md:text-xl text-neutral-400 max-w-3xl mx-auto">
                A heatmap of emergent computational complexity.
            </p>
        </header>
        
        <!-- How it Works Section -->
        <section class="mb-16 md:mb-24 flex flex-col md:flex-row items-center gap-8 md:gap-12">
            <div class="flex-1">
                <h2 class="font-orbitron text-3xl font-bold mb-4">The Engine of Creation</h2>
                <p class="text-neutral-300 mb-4 text-lg">
                    The Universal Construction Operator `U` drives everything. At each step `n`, it takes the current universe and produces the next, more complex one.
                </p>
                <p class="text-neutral-400 mt-4">
                    The core of this process is a 
                    <span class="tooltip-container text-violet-300">
                        pairing function.
                        <span class="tooltip-content">
                            A pairing function is a method that maps two natural numbers (i, j) to a single unique natural number n. Its inverse decodes n back to (i, j). This guarantees every possible pair is eventually chosen. The example below uses the Cantor "zig-zag" pairing inverse. Other methods like the Szudzik spiral exist.
                            <pre class="bg-black/30 rounded-lg p-2 mt-2 text-xs font-mono"><code class="language-js">
function getCantorPair(n) {
  const w = Math.floor((Math.sqrt(8 * n + 1) - 1) / 2);
  const t = (w * w + w) / 2;
  const j = n - t;
  const i = w - j;
  return { i, j };
}
                            </code></pre>
                        </span>
                    </span>
                    This function takes the current step number `n` and decodes it into a unique pair of indices, `i` and `j`, which are then used to build new objects.
                </p>
            </div>
            <div class="flex-1 w-full max-w-md mx-auto">
                <div class="glass-card p-4">
                    <pre class="bg-black/30 rounded-lg p-4 text-sm font-mono"><code class="language-js">
// The core operation of U at step n
function U(universeState) {
    // 1. Get step number and indices
    const n = universeState.R.length;
    const { i, j } = getCantorPair(n);

    // 2. Construct new objects
    const S_new =  (Sᵢ NOR Sⱼ) 
    const R_new = Sᵢ := Sⱼ 
    const M_new =  Mᵢ rules + Mⱼ rules + R_new 
    
    // 3. Return the new universe
    return { 
        S: [...universeState.S, S_new], 
        R: [...universeState.R, R_new], 
        M: [...universeState.M, M_new]
    };
}
                    </code></pre>
                </div>
            </div>
        </section>

        <!-- Interpreter Description and Controls Section -->
        <section class="mb-16 md:mb-24 text-center">
            <h2 class="font-orbitron text-3xl font-bold mb-4">Interpreting the Machine</h2>
            <div class="max-w-3xl mx-auto text-left">
                <p class="text-neutral-300 mb-6">
                    While all machines are constructed by concatenating their parents' rule lists, they can be executed in two distinct ways. This choice dramatically affects their behavior and the complexity that emerges. You can switch between these modes below.
                </p>
                <p class="text-neutral-400 mb-4">
                    <strong class="text-violet-400">Parallel (Set-based):</strong> In this mode, only the unique rules of a machine are considered. They are all evaluated simultaneously based on the state at the start of a step, much like a hardware logic circuit. This often leads to more complex, oscillating patterns.
                </p>
                <p class="text-neutral-400 mb-8">
                    <strong class="text-violet-400">Sequential (List-based):</strong> Here, every rule in the machine's list is executed in order, one by one. The state is updated immediately after each rule, which can influence the next rule in the sequence. This behaves more like a traditional computer script and tends to settle into simpler patterns more quickly.
                </p>
            </div>
             <div class="inline-block glass-card p-4">
                <label for="execution-mode" class="font-orbitron text-xl mr-4 align-middle">Execution Mode:</label>
                <select id="execution-mode" class="bg-neutral-800 border border-neutral-600 rounded-lg p-2 text-white font-orbitron focus:ring-violet-500 focus:border-violet-500 align-middle">
                    <option value="parallel" selected>Parallel (Set-based)</option>
                    <option value="sequential">Sequential (List-based)</option>
                </select>
            </div>
        </section>


        <!-- The Rug of Computation Section -->
        <section class="mb-16 md:mb-24">
            <h2 class="font-orbitron text-3xl font-bold text-center mb-4">The Complexity Heatmap (First 60 Machines)</h2>
            <p class="text-center text-neutral-400 max-w-3xl mx-auto mb-8">
                This is a detailed, interactive view of the first few machines generated by `U`. The lines trace the construction path, while the points are colored by the machine's cycle length. Hover over a point to see its details.
            </p>
            <div id="rug-container" class="rug-container mx-auto shadow-2xl shadow-violet-500/20">
                <svg id="rug-svg"></svg>
                <div id="rug-tooltip"></div>
            </div>
        </section>

        <!-- Pixel Heatmap Section -->
        <section class="mb-16 md:mb-24">
            <h2 class="font-orbitron text-3xl font-bold text-center mb-4">Large-Scale Heatmap (First 5,000 Machines)</h2>
            <p class="text-center text-neutral-400 max-w-3xl mx-auto mb-8">
                This is a non-interactive, high-density view of the first 5,000 machines. Each pixel represents a machine, colored by its cycle length. This provides a broader perspective on the patterns of complexity that emerge as `U` explores the space of all possible programs.
            </p>
            <div id="pixel-rug-container" class="rug-container mx-auto shadow-2xl shadow-violet-500/20">
                <canvas id="pixel-heatmap-canvas"></canvas>
            </div>
        </section>

        <!-- Challenge Section -->
        <section class="text-center">
            <h2 class="font-orbitron text-4xl font-bold text-violet-400 mb-4">The Challenge</h2>
            <p class="text-lg text-neutral-300 max-w-3xl mx-auto mb-8">
                The search for complexity is non-trivial. The most interesting machines are rare. We challenge you to find them. Download the `U.js` library and write your own program to search the computational universe for the machine with the highest cycle length.
            </p>
            <a id="download-link" href="#" download="U.js.txt" class="font-orbitron bg-violet-600 hover:bg-violet-500 text-white font-bold py-3 px-8 rounded-lg text-lg transition-all duration-300 inline-block btn-glow">
                Download U.js
            </a>
            <div class="glass-card max-w-3xl mx-auto p-6 mt-12">
                <h3 class="font-orbitron text-xl font-semibold mb-4 text-center">Cycle Hunt Log</h3>
                <div id="cycle-log" class="font-mono text-sm text-left bg-black/30 rounded p-4 overflow-x-auto">
                    <!-- Log content will be generated by script -->
                </div>
            </div>
        </section>

    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // --- DOM Element Selection ---
            const svgContainer = document.getElementById('rug-container');
            const svg = document.getElementById('rug-svg');
            const tooltip = document.getElementById('rug-tooltip');
            const pixelCanvas = document.getElementById('pixel-heatmap-canvas');
            const downloadLink = document.getElementById('download-link');
            const executionModeSelect = document.getElementById('execution-mode');
            const cycleLog = document.getElementById('cycle-log');
            
            // --- Basic Sanity Check ---
            if (!svg || !tooltip || !pixelCanvas || !downloadLink || !executionModeSelect || !cycleLog) {
                console.error("One or more essential DOM elements are missing.");
                return;
            }

            // --- Constants ---
            const HEATMAP_MAX_N = 60;
            const PIXEL_HEATMAP_MAX_N = 5000;
            const MAX_SIMULATION_STEPS = 50;

            // --- Core Universal Constructor Logic ---

            function getCantorPair(n) {
                const w = Math.floor((Math.sqrt(8 * n + 1) - 1) / 2);
                const t = (w * w + w) / 2;
                const j = n - t;
                const i = w - j;
                return { i, j };
            }

            function U_AST(universeState) {
                const n = universeState.R.length;
                let { S, R, M } = JSON.parse(JSON.stringify(universeState));
                const { i, j } = getCantorPair(n);

                if (i >= S.length || j >= S.length) return null;
                
                const S_new = { id: S.length, type: 'operation', op: 'NOR', args: [S[i].id, S[j].id] };
                const R_new = { id: R.length, type: 'assignment', lhs: S[i].id, rhs: S[j].id };
                
                const rules_i = M[i]?.rules || [];
                const rules_j = M[j]?.rules || [];
                const newMachineRules = [...rules_i, ...rules_j, R_new.id];
                const M_new = { id: M.length, type: 'machine', rules: newMachineRules };
                
                S.push(S_new);
                R.push(R_new);
                M.push(M_new);
                return { S, R, M };
            }

            // --- Machine Interpreters ---

            function evaluateSentence(sentenceId, currentStates, sentenceMap) {
                const sentence = sentenceMap.get(sentenceId);
                if (!sentence) return 0;
                if (sentence.type === 'atomic') return currentStates[sentenceId] || 0;
                if (sentence.type === 'operation' && sentence.op === 'NOR') {
                    const val1 = evaluateSentence(sentence.args[0], currentStates, sentenceMap);
                    const val2 = evaluateSentence(sentence.args[1], currentStates, sentenceMap);
                    return (val1 === 0 && val2 === 0) ? 1 : 0;
                }
                return 0;
            }

            function runMachineSequential(universe, machineId, initialStates = {}) {
                const machine = universe.M.find(m => m.id === machineId);
                if (!machine || machine.rules.length === 0) return { cycleLength: 0, history: [] };

                let sentenceStates = { ...initialStates };
                const sentenceMap = new Map(universe.S.map(s => [s.id, s]));
                const ruleMap = new Map(universe.R.map(r => [r.id, r]));
                const seenStates = new Map();
                const history = [];
                
                for (let step = 0; step < MAX_SIMULATION_STEPS; step++) {
                    const stateString = JSON.stringify(Object.entries(sentenceStates).sort());
                    history.push(sentenceStates);
                    if (seenStates.has(stateString)) {
                        const cycleLen = step - seenStates.get(stateString);
                        return { cycleLength: cycleLen === 0 ? 1 : cycleLen, history };
                    }
                    seenStates.set(stateString, step);

                    for (const ruleId of machine.rules) {
                        const rule = ruleMap.get(ruleId);
                        if (rule) {
                            const rhsValue = evaluateSentence(rule.rhs, sentenceStates, sentenceMap);
                            sentenceStates[rule.lhs] = rhsValue;
                        }
                    }
                }
                return { cycleLength: MAX_SIMULATION_STEPS, history };
            }

            function runMachineParallel(universe, machineId, initialStates = {}) {
                const machine = universe.M.find(m => m.id === machineId);
                if (!machine) return { cycleLength: 0, history: [] };

                const uniqueRuleIds = [...new Set(machine.rules)];
                if (uniqueRuleIds.length === 0) return { cycleLength: 0, history: [] };

                let sentenceStates = { ...initialStates };
                const sentenceMap = new Map(universe.S.map(s => [s.id, s]));
                const ruleMap = new Map(universe.R.map(r => [r.id, r]));
                const seenStates = new Map();
                const history = [];

                for (let step = 0; step < MAX_SIMULATION_STEPS; step++) {
                    const stateString = JSON.stringify(Object.entries(sentenceStates).sort());
                    history.push(sentenceStates);
                    if (seenStates.has(stateString)) {
                        const cycleLen = step - seenStates.get(stateString);
                        return { cycleLength: cycleLen === 0 ? 1 : cycleLen, history };
                    }
                    seenStates.set(stateString, step);

                    const nextStates = {};
                    for (const ruleId of uniqueRuleIds) {
                        const rule = ruleMap.get(ruleId);
                        if (rule) {
                            const rhsValue = evaluateSentence(rule.rhs, sentenceStates, sentenceMap);
                            nextStates[rule.lhs] = rhsValue;
                        }
                    }
                    sentenceStates = { ...sentenceStates, ...nextStates };
                }
                return { cycleLength: MAX_SIMULATION_STEPS, history };
            }

            // --- Visualization Logic ---

            function getHeatmapColor(value, maxValue) {
                if (value === 0) return `rgb(100, 100, 100)`;
                if (value === 1) return `rgb(0, 0, 255)`;
                if (value === 2) return `rgb(0, 255, 0)`;
                if (value === 3) return `rgb(255, 0, 0)`;
                if (value === 4) return `rgb(255, 255, 0)`;
                const hue = Math.max(0, 240 - ((value - 2) / (maxValue - 2)) * 240);
                const f = (n, k = (n + hue / 60) % 6) => 0.5 - 0.4 * Math.max(Math.min(k, 4 - k, 1), -1);
                return `rgb(${f(5) * 255}, ${f(3) * 255}, ${f(1) * 255})`;
            }

            function formatSentenceAST(s) {
                if (!s) return 'undefined';
                if (s.type === 'atomic') return s.name;
                if (s.type === 'operation') return `(S${s.args[0]} NOR S${s.args[1]})`;
                return `S${s.id}`;
            }
            
            // --- Heatmap Generation ---

            function generateInteractiveHeatmap(runInterpreter) {
                svg.innerHTML = ''; // Clear previous SVG content
                const size = 600;
                svg.setAttribute('viewBox', `0 0 ${size} ${size}`);
                const gridSize = Math.ceil(Math.sqrt(HEATMAP_MAX_N)) + 3;
                const scale = size / gridSize;
                const padding = scale / 2;

                let universe = { S: [{ id: 0, type: 'atomic', name: 'p' }, { id: 1, type: 'atomic', name: 'q' }], R: [], M: [] };
                let pointsData = [];
                let universeHistory = [];

                for (let n = 0; n <= HEATMAP_MAX_N; n++) {
                    const { i, j } = getCantorPair(n);
                    while (universe.M.length <= i || universe.M.length <= j) {
                        universe.M.push({ id: universe.M.length, type: 'machine', rules: [] });
                    }
                    universeHistory.push(JSON.parse(JSON.stringify(universe)));
                    const nextUniverse = U_AST(universe);
                    if (!nextUniverse) continue;
                    universe = nextUniverse;
                    const machineId = universe.M.length - 1;
                    const { cycleLength } = runInterpreter(universe, machineId, { 0: 1 });
                    pointsData.push({ p: { x: i * scale + padding, y: j * scale + padding }, cycleLength, n, i, j });
                }

                pointsData.forEach(data => {
                    const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    circle.setAttribute('cx', data.p.x);
                    circle.setAttribute('cy', data.p.y);
                    circle.setAttribute('r', 18);
                    circle.setAttribute('fill', getHeatmapColor(data.cycleLength, MAX_SIMULATION_STEPS));
                    circle.style.cursor = 'pointer';
                    svg.appendChild(circle);

                    circle.addEventListener('mouseover', (e) => {
                        const historicalUniverse = universeHistory[data.n];
                        tooltip.innerHTML = `n=${data.n} (i=${data.i}, j=${data.j}) | Cycle: ${data.cycleLength || 'Halt'}`;
                        tooltip.style.left = `${e.clientX - svgContainer.getBoundingClientRect().left + 15}px`;
                        tooltip.style.top = `${e.clientY - svgContainer.getBoundingClientRect().top + 15}px`;
                        tooltip.style.visibility = 'visible';
                        tooltip.style.opacity = '1';
                    });
                    circle.addEventListener('mouseout', () => {
                        tooltip.style.visibility = 'hidden';
                        tooltip.style.opacity = '0';
                    });
                });
            }

            async function generatePixelHeatmap(runInterpreter) {
                const max_ij = Math.ceil(Math.sqrt(PIXEL_HEATMAP_MAX_N)) + 2;
                pixelCanvas.width = max_ij;
                pixelCanvas.height = max_ij;
                const ctx = pixelCanvas.getContext('2d');
                ctx.fillStyle = '#f0f0f0';
                ctx.fillRect(0, 0, max_ij, max_ij);

                let universe = { S: [{ id: 0, type: 'atomic', name: 'p' }, { id: 1, type: 'atomic', name: 'q' }], R: [], M: [] };
                let highestCycleFound = 0;
                let logHTML = '';

                const chunkSize = 200;
                for (let n_start = 0; n_start < PIXEL_HEATMAP_MAX_N; n_start += chunkSize) {
                    const n_end = Math.min(n_start + chunkSize, PIXEL_HEATMAP_MAX_N);
                    for (let n = n_start; n < n_end; n++) {
                        const { i, j } = getCantorPair(n);
                        while (universe.M.length <= i || universe.M.length <= j) {
                            universe.M.push({ id: universe.M.length, type: 'machine', rules: [] });
                        }
                        const nextUniverse = U_AST(universe);
                        if (!nextUniverse) continue;
                        universe = nextUniverse;
                        const machineId = universe.M.length - 1;
                        const { cycleLength } = runInterpreter(universe, machineId, { 0: 1 });
                        if (cycleLength > highestCycleFound) {
                            highestCycleFound = cycleLength;
                            logHTML += `<p class="text-green-400">*** New Highest Cycle Found: ${highestCycleFound} at n=${n} ***</p>`;
                        }
                        ctx.fillStyle = getHeatmapColor(cycleLength, MAX_SIMULATION_STEPS);
                        ctx.fillRect(i, j, 1, 1);
                    }
                    await new Promise(resolve => setTimeout(resolve, 0));
                }
                cycleLog.innerHTML = logHTML || '<p class="text-neutral-400">No new cycles found yet.</p>';
            }

            // --- U.js Download Link Setup ---
            function setupDownloadLink() {
                const jsCode = `
// U.js - A library for the Universal Construction Operator
// This library includes both parallel and sequential machine interpreters.
const U = (() => {
    function getCantorPair(n) {
        const w = Math.floor((Math.sqrt(8 * n + 1) - 1) / 2);
        const t = (w * w + w) / 2;
        const j = n - t;
        const i = w - j;
        return { i, j };
    }

    function U_AST(universeState) {
        const n = universeState.R.length;
        let { S, R, M } = JSON.parse(JSON.stringify(universeState));
        const { i, j } = getCantorPair(n);
        if (i >= S.length || j >= S.length) return null;
        
        const S_new = { id: S.length, type: 'operation', op: 'NOR', args: [S[i].id, S[j].id] };
        const R_new = { id: R.length, type: 'assignment', lhs: S[i].id, rhs: S[j].id };
        
        const rules_i = M[i]?.rules || [];
        const rules_j = M[j]?.rules || [];
        const newMachineRules = [...rules_i, ...rules_j, R_new.id];
        const M_new = { id: M.length, type: 'machine', rules: newMachineRules };
        
        S.push(S_new);
        R.push(R_new);
        M.push(M_new);
        return { S, R, M };
    }

    function evaluateSentence(sentenceId, currentStates, sentenceMap) {
        const sentence = sentenceMap.get(sentenceId);
        if (!sentence) return 0;
        if (sentence.type === 'atomic') return currentStates[sentenceId] || 0;
        if (sentence.type === 'operation' && sentence.op === 'NOR') {
            const val1 = evaluateSentence(sentence.args[0], currentStates, sentenceMap);
            const val2 = evaluateSentence(sentence.args[1], currentStates, sentenceMap);
            return (val1 === 0 && val2 === 0) ? 1 : 0;
        }
        return 0;
    }

    function runMachineSequential(universe, machineId, initialStates = {}, maxSteps = 50) {
        const machine = universe.M.find(m => m.id === machineId);
        if (!machine || machine.rules.length === 0) return { cycleLength: 0 };

        let sentenceStates = { ...initialStates };
        const sentenceMap = new Map(universe.S.map(s => [s.id, s]));
        const ruleMap = new Map(universe.R.map(r => [r.id, r]));
        const seenStates = new Map();
        
        for (let step = 0; step < maxSteps; step++) {
            const stateString = JSON.stringify(Object.entries(sentenceStates).sort());
            if (seenStates.has(stateString)) {
                const cycleLen = step - seenStates.get(stateString);
                return { cycleLength: cycleLen === 0 ? 1 : cycleLen };
            }
            seenStates.set(stateString, step);

            for (const ruleId of machine.rules) {
                const rule = ruleMap.get(ruleId);
                if (rule) {
                    const rhsValue = evaluateSentence(rule.rhs, sentenceStates, sentenceMap);
                    sentenceStates[rule.lhs] = rhsValue;
                }
            }
        }
        return { cycleLength: maxSteps };
    }

    function runMachineParallel(universe, machineId, initialStates = {}, maxSteps = 50) {
        const machine = universe.M.find(m => m.id === machineId);
        if (!machine) return { cycleLength: 0 };

        const uniqueRuleIds = [...new Set(machine.rules)];
        if (uniqueRuleIds.length === 0) return { cycleLength: 0 };

        let sentenceStates = { ...initialStates };
        const sentenceMap = new Map(universe.S.map(s => [s.id, s]));
        const ruleMap = new Map(universe.R.map(r => [r.id, r]));
        const seenStates = new Map();

        for (let step = 0; step < maxSteps; step++) {
            const stateString = JSON.stringify(Object.entries(sentenceStates).sort());
            if (seenStates.has(stateString)) {
                const cycleLen = step - seenStates.get(stateString);
                return { cycleLength: cycleLen === 0 ? 1 : cycleLen };
            }
            seenStates.set(stateString, step);

            const nextStates = {};
            for (const ruleId of uniqueRuleIds) {
                const rule = ruleMap.get(ruleId);
                if (rule) {
                    const rhsValue = evaluateSentence(rule.rhs, sentenceStates, sentenceMap);
                    nextStates[rule.lhs] = rhsValue;
                }
            }
            sentenceStates = { ...sentenceStates, ...nextStates };
        }
        return { cycleLength: maxSteps };
    }

    return { 
        getCantorPair, 
        U_AST, 
        runMachineSequential, 
        runMachineParallel 
    };
})();
                `;
                const encodedJs = encodeURIComponent(jsCode.trim());
                downloadLink.href = 'data:text/plain;charset=utf-8,' + encodedJs;
            }

            // --- Main Execution Logic ---

            function regenerateAll() {
                const mode = executionModeSelect.value;
                const interpreter = (mode === 'parallel') ? runMachineParallel : runMachineSequential;
                
                cycleLog.innerHTML = '<p class="text-amber-400">Searching for complex machines...</p>';

                setTimeout(() => {
                    generateInteractiveHeatmap(interpreter);
                    generatePixelHeatmap(interpreter);
                }, 10);
            }

            executionModeSelect.addEventListener('change', regenerateAll);
            regenerateAll(); // Initial run on page load
            setupDownloadLink(); // Set up the download link content
        });
    </script>

</body>
</html>
